// Code generated by protoc-gen-go.
// source: pawd.proto
// DO NOT EDIT!

/*
Package pawd is a generated protocol buffer package.

Package pawd contains types and interfaces for the API to interact with pawd,
a very fuzzy package repository server.

It is generated from these files:
	pawd.proto

It has these top-level messages:
	Nil
	RegisterInfo
	RegisterResponse
	LoginInfo
	UserToken
	RepoCreate
	Repo
	Package
	PackageName
	RepoName
	RepoMeta
	RepoPackages
	PackageTemplate
	RepoAddPackage
	RepoUpdatePackage
	PackageBuildID
	PackageBuild
	PackageBuildHistory
*/
package pawd

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Distro int32

const (
	Distro_None       Distro = 0
	Distro_AlpineEdge Distro = 10
	Distro_Alpine33   Distro = 11
	Distro_Alpine34   Distro = 12
	Distro_Alpine35   Distro = 13
	Distro_Alpine36   Distro = 14
	Distro_Alpine37   Distro = 15
	Distro_AdelieEdge Distro = 110
)

var Distro_name = map[int32]string{
	0:   "None",
	10:  "AlpineEdge",
	11:  "Alpine33",
	12:  "Alpine34",
	13:  "Alpine35",
	14:  "Alpine36",
	15:  "Alpine37",
	110: "AdelieEdge",
}
var Distro_value = map[string]int32{
	"None":       0,
	"AlpineEdge": 10,
	"Alpine33":   11,
	"Alpine34":   12,
	"Alpine35":   13,
	"Alpine36":   14,
	"Alpine37":   15,
	"AdelieEdge": 110,
}

func (x Distro) String() string {
	return proto.EnumName(Distro_name, int32(x))
}
func (Distro) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type PackageTemplate_Kind int32

const (
	PackageTemplate_GoTag          PackageTemplate_Kind = 0
	PackageTemplate_GoLatestCommit PackageTemplate_Kind = 1
)

var PackageTemplate_Kind_name = map[int32]string{
	0: "GoTag",
	1: "GoLatestCommit",
}
var PackageTemplate_Kind_value = map[string]int32{
	"GoTag":          0,
	"GoLatestCommit": 1,
}

func (x PackageTemplate_Kind) String() string {
	return proto.EnumName(PackageTemplate_Kind_name, int32(x))
}
func (PackageTemplate_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 0} }

// Nil is nothing.
type Nil struct {
}

func (m *Nil) Reset()                    { *m = Nil{} }
func (m *Nil) String() string            { return proto.CompactTextString(m) }
func (*Nil) ProtoMessage()               {}
func (*Nil) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type RegisterInfo struct {
	Email    string `protobuf:"bytes,1,opt,name=email" json:"email,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	WantTotp bool   `protobuf:"varint,3,opt,name=want_totp,json=wantTotp" json:"want_totp,omitempty"`
}

func (m *RegisterInfo) Reset()                    { *m = RegisterInfo{} }
func (m *RegisterInfo) String() string            { return proto.CompactTextString(m) }
func (*RegisterInfo) ProtoMessage()               {}
func (*RegisterInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *RegisterInfo) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *RegisterInfo) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *RegisterInfo) GetWantTotp() bool {
	if m != nil {
		return m.WantTotp
	}
	return false
}

type RegisterResponse struct {
	Token      *UserToken `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	Email      string     `protobuf:"bytes,2,opt,name=email" json:"email,omitempty"`
	TotpSecret string     `protobuf:"bytes,3,opt,name=totp_secret,json=totpSecret" json:"totp_secret,omitempty"`
}

func (m *RegisterResponse) Reset()                    { *m = RegisterResponse{} }
func (m *RegisterResponse) String() string            { return proto.CompactTextString(m) }
func (*RegisterResponse) ProtoMessage()               {}
func (*RegisterResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *RegisterResponse) GetToken() *UserToken {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *RegisterResponse) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *RegisterResponse) GetTotpSecret() string {
	if m != nil {
		return m.TotpSecret
	}
	return ""
}

type LoginInfo struct {
	Email         string `protobuf:"bytes,1,opt,name=email" json:"email,omitempty"`
	Password      string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	TotpChallenge string `protobuf:"bytes,3,opt,name=totp_challenge,json=totpChallenge" json:"totp_challenge,omitempty"`
}

func (m *LoginInfo) Reset()                    { *m = LoginInfo{} }
func (m *LoginInfo) String() string            { return proto.CompactTextString(m) }
func (*LoginInfo) ProtoMessage()               {}
func (*LoginInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *LoginInfo) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *LoginInfo) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *LoginInfo) GetTotpChallenge() string {
	if m != nil {
		return m.TotpChallenge
	}
	return ""
}

type UserToken struct {
	Token         string   `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	Flags         []string `protobuf:"bytes,2,rep,name=flags" json:"flags,omitempty"`
	ExpiryUnixGmt int64    `protobuf:"varint,3,opt,name=expiry_unix_gmt,json=expiryUnixGmt" json:"expiry_unix_gmt,omitempty"`
}

func (m *UserToken) Reset()                    { *m = UserToken{} }
func (m *UserToken) String() string            { return proto.CompactTextString(m) }
func (*UserToken) ProtoMessage()               {}
func (*UserToken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *UserToken) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *UserToken) GetFlags() []string {
	if m != nil {
		return m.Flags
	}
	return nil
}

func (m *UserToken) GetExpiryUnixGmt() int64 {
	if m != nil {
		return m.ExpiryUnixGmt
	}
	return 0
}

type RepoCreate struct {
	Name         string   `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Description  string   `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	Distros      []Distro `protobuf:"varint,3,rep,packed,name=distros,enum=pawd.Distro" json:"distros,omitempty"`
	PersonalHack bool     `protobuf:"varint,4,opt,name=personal_hack,json=personalHack" json:"personal_hack,omitempty"`
}

func (m *RepoCreate) Reset()                    { *m = RepoCreate{} }
func (m *RepoCreate) String() string            { return proto.CompactTextString(m) }
func (*RepoCreate) ProtoMessage()               {}
func (*RepoCreate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *RepoCreate) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RepoCreate) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RepoCreate) GetDistros() []Distro {
	if m != nil {
		return m.Distros
	}
	return nil
}

func (m *RepoCreate) GetPersonalHack() bool {
	if m != nil {
		return m.PersonalHack
	}
	return false
}

type Repo struct {
	Id                  string   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name                string   `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Description         string   `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	Distros             []Distro `protobuf:"varint,4,rep,packed,name=distros,enum=pawd.Distro" json:"distros,omitempty"`
	PersonalHack        bool     `protobuf:"varint,5,opt,name=personal_hack,json=personalHack" json:"personal_hack,omitempty"`
	CreationDateUnixGmt int64    `protobuf:"varint,6,opt,name=creation_date_unix_gmt,json=creationDateUnixGmt" json:"creation_date_unix_gmt,omitempty"`
}

func (m *Repo) Reset()                    { *m = Repo{} }
func (m *Repo) String() string            { return proto.CompactTextString(m) }
func (*Repo) ProtoMessage()               {}
func (*Repo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Repo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Repo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Repo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Repo) GetDistros() []Distro {
	if m != nil {
		return m.Distros
	}
	return nil
}

func (m *Repo) GetPersonalHack() bool {
	if m != nil {
		return m.PersonalHack
	}
	return false
}

func (m *Repo) GetCreationDateUnixGmt() int64 {
	if m != nil {
		return m.CreationDateUnixGmt
	}
	return 0
}

type Package struct {
	Id      string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name    string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Version string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
	Pkgrel  string `protobuf:"bytes,4,opt,name=pkgrel" json:"pkgrel,omitempty"`
	Pkgdesc string `protobuf:"bytes,5,opt,name=pkgdesc" json:"pkgdesc,omitempty"`
	License string `protobuf:"bytes,6,opt,name=license" json:"license,omitempty"`
}

func (m *Package) Reset()                    { *m = Package{} }
func (m *Package) String() string            { return proto.CompactTextString(m) }
func (*Package) ProtoMessage()               {}
func (*Package) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Package) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Package) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Package) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Package) GetPkgrel() string {
	if m != nil {
		return m.Pkgrel
	}
	return ""
}

func (m *Package) GetPkgdesc() string {
	if m != nil {
		return m.Pkgdesc
	}
	return ""
}

func (m *Package) GetLicense() string {
	if m != nil {
		return m.License
	}
	return ""
}

type PackageName struct {
	Name     string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	User     string `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	RepoName string `protobuf:"bytes,3,opt,name=repo_name,json=repoName" json:"repo_name,omitempty"`
}

func (m *PackageName) Reset()                    { *m = PackageName{} }
func (m *PackageName) String() string            { return proto.CompactTextString(m) }
func (*PackageName) ProtoMessage()               {}
func (*PackageName) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *PackageName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PackageName) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *PackageName) GetRepoName() string {
	if m != nil {
		return m.RepoName
	}
	return ""
}

type RepoName struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	User string `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
}

func (m *RepoName) Reset()                    { *m = RepoName{} }
func (m *RepoName) String() string            { return proto.CompactTextString(m) }
func (*RepoName) ProtoMessage()               {}
func (*RepoName) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *RepoName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RepoName) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

type RepoMeta struct {
	Id           string   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name         string   `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Description  string   `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	Distros      []Distro `protobuf:"varint,4,rep,packed,name=distros,enum=pawd.Distro" json:"distros,omitempty"`
	PersonalHack bool     `protobuf:"varint,5,opt,name=personal_hack,json=personalHack" json:"personal_hack,omitempty"`
}

func (m *RepoMeta) Reset()                    { *m = RepoMeta{} }
func (m *RepoMeta) String() string            { return proto.CompactTextString(m) }
func (*RepoMeta) ProtoMessage()               {}
func (*RepoMeta) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *RepoMeta) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *RepoMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RepoMeta) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RepoMeta) GetDistros() []Distro {
	if m != nil {
		return m.Distros
	}
	return nil
}

func (m *RepoMeta) GetPersonalHack() bool {
	if m != nil {
		return m.PersonalHack
	}
	return false
}

type RepoPackages struct {
	Repo     *Repo      `protobuf:"bytes,1,opt,name=repo" json:"repo,omitempty"`
	Packages []*Package `protobuf:"bytes,2,rep,name=packages" json:"packages,omitempty"`
}

func (m *RepoPackages) Reset()                    { *m = RepoPackages{} }
func (m *RepoPackages) String() string            { return proto.CompactTextString(m) }
func (*RepoPackages) ProtoMessage()               {}
func (*RepoPackages) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *RepoPackages) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *RepoPackages) GetPackages() []*Package {
	if m != nil {
		return m.Packages
	}
	return nil
}

type PackageTemplate struct {
	Meta       *Package             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Kind       PackageTemplate_Kind `protobuf:"varint,2,opt,name=kind,enum=pawd.PackageTemplate_Kind" json:"kind,omitempty"`
	SourceUrl  string               `protobuf:"bytes,3,opt,name=source_url,json=sourceUrl" json:"source_url,omitempty"`
	GitRepo    string               `protobuf:"bytes,4,opt,name=git_repo,json=gitRepo" json:"git_repo,omitempty"`
	Depends    []string             `protobuf:"bytes,5,rep,name=depends" json:"depends,omitempty"`
	DevDepends []string             `protobuf:"bytes,6,rep,name=dev_depends,json=devDepends" json:"dev_depends,omitempty"`
	// only relevant for go packages
	GoImport  string   `protobuf:"bytes,100,opt,name=go_import,json=goImport" json:"go_import,omitempty"`
	GoPkg     string   `protobuf:"bytes,101,opt,name=go_pkg,json=goPkg" json:"go_pkg,omitempty"`
	GoInstall []string `protobuf:"bytes,102,rep,name=go_install,json=goInstall" json:"go_install,omitempty"`
}

func (m *PackageTemplate) Reset()                    { *m = PackageTemplate{} }
func (m *PackageTemplate) String() string            { return proto.CompactTextString(m) }
func (*PackageTemplate) ProtoMessage()               {}
func (*PackageTemplate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *PackageTemplate) GetMeta() *Package {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *PackageTemplate) GetKind() PackageTemplate_Kind {
	if m != nil {
		return m.Kind
	}
	return PackageTemplate_GoTag
}

func (m *PackageTemplate) GetSourceUrl() string {
	if m != nil {
		return m.SourceUrl
	}
	return ""
}

func (m *PackageTemplate) GetGitRepo() string {
	if m != nil {
		return m.GitRepo
	}
	return ""
}

func (m *PackageTemplate) GetDepends() []string {
	if m != nil {
		return m.Depends
	}
	return nil
}

func (m *PackageTemplate) GetDevDepends() []string {
	if m != nil {
		return m.DevDepends
	}
	return nil
}

func (m *PackageTemplate) GetGoImport() string {
	if m != nil {
		return m.GoImport
	}
	return ""
}

func (m *PackageTemplate) GetGoPkg() string {
	if m != nil {
		return m.GoPkg
	}
	return ""
}

func (m *PackageTemplate) GetGoInstall() []string {
	if m != nil {
		return m.GoInstall
	}
	return nil
}

type RepoAddPackage struct {
	// the gzipped tarballed bytes of the APKBUILD and files it depends on. Limit 5 MB.
	BuildTarballGzipped []byte `protobuf:"bytes,2,opt,name=build_tarball_gzipped,json=buildTarballGzipped,proto3" json:"build_tarball_gzipped,omitempty"`
}

func (m *RepoAddPackage) Reset()                    { *m = RepoAddPackage{} }
func (m *RepoAddPackage) String() string            { return proto.CompactTextString(m) }
func (*RepoAddPackage) ProtoMessage()               {}
func (*RepoAddPackage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *RepoAddPackage) GetBuildTarballGzipped() []byte {
	if m != nil {
		return m.BuildTarballGzipped
	}
	return nil
}

type RepoUpdatePackage struct {
	// version numbers must be increased
	Meta *Package `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	// the gzipped tarballed bytes of the APKBUILD and files it depends on. Limit 5 MB.
	BuildTarballGzipped []byte `protobuf:"bytes,3,opt,name=build_tarball_gzipped,json=buildTarballGzipped,proto3" json:"build_tarball_gzipped,omitempty"`
}

func (m *RepoUpdatePackage) Reset()                    { *m = RepoUpdatePackage{} }
func (m *RepoUpdatePackage) String() string            { return proto.CompactTextString(m) }
func (*RepoUpdatePackage) ProtoMessage()               {}
func (*RepoUpdatePackage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *RepoUpdatePackage) GetMeta() *Package {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *RepoUpdatePackage) GetBuildTarballGzipped() []byte {
	if m != nil {
		return m.BuildTarballGzipped
	}
	return nil
}

type PackageBuildID struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *PackageBuildID) Reset()                    { *m = PackageBuildID{} }
func (m *PackageBuildID) String() string            { return proto.CompactTextString(m) }
func (*PackageBuildID) ProtoMessage()               {}
func (*PackageBuildID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *PackageBuildID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type PackageBuild struct {
	Id               string   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Pkg              *Package `protobuf:"bytes,2,opt,name=pkg" json:"pkg,omitempty"`
	User             string   `protobuf:"bytes,3,opt,name=user" json:"user,omitempty"`
	StartDateUnixGmt int64    `protobuf:"varint,4,opt,name=start_date_unix_gmt,json=startDateUnixGmt" json:"start_date_unix_gmt,omitempty"`
	EndDateUnixGmt   int64    `protobuf:"varint,5,opt,name=end_date_unix_gmt,json=endDateUnixGmt" json:"end_date_unix_gmt,omitempty"`
	Passed           bool     `protobuf:"varint,6,opt,name=passed" json:"passed,omitempty"`
	BuildOutput      []byte   `protobuf:"bytes,7,opt,name=build_output,json=buildOutput,proto3" json:"build_output,omitempty"`
	Distro           Distro   `protobuf:"varint,8,opt,name=distro,enum=pawd.Distro" json:"distro,omitempty"`
}

func (m *PackageBuild) Reset()                    { *m = PackageBuild{} }
func (m *PackageBuild) String() string            { return proto.CompactTextString(m) }
func (*PackageBuild) ProtoMessage()               {}
func (*PackageBuild) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *PackageBuild) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PackageBuild) GetPkg() *Package {
	if m != nil {
		return m.Pkg
	}
	return nil
}

func (m *PackageBuild) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *PackageBuild) GetStartDateUnixGmt() int64 {
	if m != nil {
		return m.StartDateUnixGmt
	}
	return 0
}

func (m *PackageBuild) GetEndDateUnixGmt() int64 {
	if m != nil {
		return m.EndDateUnixGmt
	}
	return 0
}

func (m *PackageBuild) GetPassed() bool {
	if m != nil {
		return m.Passed
	}
	return false
}

func (m *PackageBuild) GetBuildOutput() []byte {
	if m != nil {
		return m.BuildOutput
	}
	return nil
}

func (m *PackageBuild) GetDistro() Distro {
	if m != nil {
		return m.Distro
	}
	return Distro_None
}

type PackageBuildHistory struct {
	AsOfUnixGmt int64           `protobuf:"varint,1,opt,name=as_of_unix_gmt,json=asOfUnixGmt" json:"as_of_unix_gmt,omitempty"`
	Builds      []*PackageBuild `protobuf:"bytes,2,rep,name=builds" json:"builds,omitempty"`
}

func (m *PackageBuildHistory) Reset()                    { *m = PackageBuildHistory{} }
func (m *PackageBuildHistory) String() string            { return proto.CompactTextString(m) }
func (*PackageBuildHistory) ProtoMessage()               {}
func (*PackageBuildHistory) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *PackageBuildHistory) GetAsOfUnixGmt() int64 {
	if m != nil {
		return m.AsOfUnixGmt
	}
	return 0
}

func (m *PackageBuildHistory) GetBuilds() []*PackageBuild {
	if m != nil {
		return m.Builds
	}
	return nil
}

func init() {
	proto.RegisterType((*Nil)(nil), "pawd.Nil")
	proto.RegisterType((*RegisterInfo)(nil), "pawd.RegisterInfo")
	proto.RegisterType((*RegisterResponse)(nil), "pawd.RegisterResponse")
	proto.RegisterType((*LoginInfo)(nil), "pawd.LoginInfo")
	proto.RegisterType((*UserToken)(nil), "pawd.UserToken")
	proto.RegisterType((*RepoCreate)(nil), "pawd.RepoCreate")
	proto.RegisterType((*Repo)(nil), "pawd.Repo")
	proto.RegisterType((*Package)(nil), "pawd.Package")
	proto.RegisterType((*PackageName)(nil), "pawd.PackageName")
	proto.RegisterType((*RepoName)(nil), "pawd.RepoName")
	proto.RegisterType((*RepoMeta)(nil), "pawd.RepoMeta")
	proto.RegisterType((*RepoPackages)(nil), "pawd.RepoPackages")
	proto.RegisterType((*PackageTemplate)(nil), "pawd.PackageTemplate")
	proto.RegisterType((*RepoAddPackage)(nil), "pawd.RepoAddPackage")
	proto.RegisterType((*RepoUpdatePackage)(nil), "pawd.RepoUpdatePackage")
	proto.RegisterType((*PackageBuildID)(nil), "pawd.PackageBuildID")
	proto.RegisterType((*PackageBuild)(nil), "pawd.PackageBuild")
	proto.RegisterType((*PackageBuildHistory)(nil), "pawd.PackageBuildHistory")
	proto.RegisterEnum("pawd.Distro", Distro_name, Distro_value)
	proto.RegisterEnum("pawd.PackageTemplate_Kind", PackageTemplate_Kind_name, PackageTemplate_Kind_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Auth service

type AuthClient interface {
	// Register allows any unauthenticated client to create a new account with
	// a given set of credentials. If the user wants they can force all actions
	// to require a TOTP challenge in each api call.
	Register(ctx context.Context, in *RegisterInfo, opts ...grpc.CallOption) (*UserToken, error)
	// Login allows any unauthenticated client to attempt to create a new access
	// token given the email address, password and totp challenge (if applicable)
	// are set.
	Login(ctx context.Context, in *LoginInfo, opts ...grpc.CallOption) (*UserToken, error)
	// Logout allows any authenticated client to destroy its API token, making it
	// unusable in the future.
	Logout(ctx context.Context, in *UserToken, opts ...grpc.CallOption) (*Nil, error)
}

type authClient struct {
	cc *grpc.ClientConn
}

func NewAuthClient(cc *grpc.ClientConn) AuthClient {
	return &authClient{cc}
}

func (c *authClient) Register(ctx context.Context, in *RegisterInfo, opts ...grpc.CallOption) (*UserToken, error) {
	out := new(UserToken)
	err := grpc.Invoke(ctx, "/pawd.Auth/Register", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Login(ctx context.Context, in *LoginInfo, opts ...grpc.CallOption) (*UserToken, error) {
	out := new(UserToken)
	err := grpc.Invoke(ctx, "/pawd.Auth/Login", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Logout(ctx context.Context, in *UserToken, opts ...grpc.CallOption) (*Nil, error) {
	out := new(Nil)
	err := grpc.Invoke(ctx, "/pawd.Auth/Logout", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Auth service

type AuthServer interface {
	// Register allows any unauthenticated client to create a new account with
	// a given set of credentials. If the user wants they can force all actions
	// to require a TOTP challenge in each api call.
	Register(context.Context, *RegisterInfo) (*UserToken, error)
	// Login allows any unauthenticated client to attempt to create a new access
	// token given the email address, password and totp challenge (if applicable)
	// are set.
	Login(context.Context, *LoginInfo) (*UserToken, error)
	// Logout allows any authenticated client to destroy its API token, making it
	// unusable in the future.
	Logout(context.Context, *UserToken) (*Nil, error)
}

func RegisterAuthServer(s *grpc.Server, srv AuthServer) {
	s.RegisterService(&_Auth_serviceDesc, srv)
}

func _Auth_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pawd.Auth/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).Register(ctx, req.(*RegisterInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pawd.Auth/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).Login(ctx, req.(*LoginInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Auth_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pawd.Auth/Logout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServer).Logout(ctx, req.(*UserToken))
	}
	return interceptor(ctx, in, info, handler)
}

var _Auth_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pawd.Auth",
	HandlerType: (*AuthServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _Auth_Register_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _Auth_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _Auth_Logout_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pawd.proto",
}

// Client API for Repos service

type ReposClient interface {
	Create(ctx context.Context, in *RepoCreate, opts ...grpc.CallOption) (*Repo, error)
	Delete(ctx context.Context, in *RepoName, opts ...grpc.CallOption) (*Nil, error)
	Info(ctx context.Context, in *RepoName, opts ...grpc.CallOption) (*Repo, error)
	UpdateInfo(ctx context.Context, in *RepoMeta, opts ...grpc.CallOption) (*Repo, error)
	Packages(ctx context.Context, in *RepoName, opts ...grpc.CallOption) (*RepoPackages, error)
	AddPackage(ctx context.Context, in *RepoAddPackage, opts ...grpc.CallOption) (*PackageBuild, error)
	// rpc DelPackage(RepoDelPackage) returns (Nil) {}
	UpdatePackage(ctx context.Context, in *RepoUpdatePackage, opts ...grpc.CallOption) (*PackageBuild, error)
	Builds(ctx context.Context, in *PackageName, opts ...grpc.CallOption) (*PackageBuildHistory, error)
	CheckBuild(ctx context.Context, in *PackageBuildID, opts ...grpc.CallOption) (*PackageBuild, error)
}

type reposClient struct {
	cc *grpc.ClientConn
}

func NewReposClient(cc *grpc.ClientConn) ReposClient {
	return &reposClient{cc}
}

func (c *reposClient) Create(ctx context.Context, in *RepoCreate, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/pawd.Repos/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Delete(ctx context.Context, in *RepoName, opts ...grpc.CallOption) (*Nil, error) {
	out := new(Nil)
	err := grpc.Invoke(ctx, "/pawd.Repos/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Info(ctx context.Context, in *RepoName, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/pawd.Repos/Info", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) UpdateInfo(ctx context.Context, in *RepoMeta, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/pawd.Repos/UpdateInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Packages(ctx context.Context, in *RepoName, opts ...grpc.CallOption) (*RepoPackages, error) {
	out := new(RepoPackages)
	err := grpc.Invoke(ctx, "/pawd.Repos/Packages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) AddPackage(ctx context.Context, in *RepoAddPackage, opts ...grpc.CallOption) (*PackageBuild, error) {
	out := new(PackageBuild)
	err := grpc.Invoke(ctx, "/pawd.Repos/AddPackage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) UpdatePackage(ctx context.Context, in *RepoUpdatePackage, opts ...grpc.CallOption) (*PackageBuild, error) {
	out := new(PackageBuild)
	err := grpc.Invoke(ctx, "/pawd.Repos/UpdatePackage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Builds(ctx context.Context, in *PackageName, opts ...grpc.CallOption) (*PackageBuildHistory, error) {
	out := new(PackageBuildHistory)
	err := grpc.Invoke(ctx, "/pawd.Repos/Builds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) CheckBuild(ctx context.Context, in *PackageBuildID, opts ...grpc.CallOption) (*PackageBuild, error) {
	out := new(PackageBuild)
	err := grpc.Invoke(ctx, "/pawd.Repos/CheckBuild", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Repos service

type ReposServer interface {
	Create(context.Context, *RepoCreate) (*Repo, error)
	Delete(context.Context, *RepoName) (*Nil, error)
	Info(context.Context, *RepoName) (*Repo, error)
	UpdateInfo(context.Context, *RepoMeta) (*Repo, error)
	Packages(context.Context, *RepoName) (*RepoPackages, error)
	AddPackage(context.Context, *RepoAddPackage) (*PackageBuild, error)
	// rpc DelPackage(RepoDelPackage) returns (Nil) {}
	UpdatePackage(context.Context, *RepoUpdatePackage) (*PackageBuild, error)
	Builds(context.Context, *PackageName) (*PackageBuildHistory, error)
	CheckBuild(context.Context, *PackageBuildID) (*PackageBuild, error)
}

func RegisterReposServer(s *grpc.Server, srv ReposServer) {
	s.RegisterService(&_Repos_serviceDesc, srv)
}

func _Repos_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepoCreate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReposServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pawd.Repos/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReposServer).Create(ctx, req.(*RepoCreate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repos_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepoName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReposServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pawd.Repos/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReposServer).Delete(ctx, req.(*RepoName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repos_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepoName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReposServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pawd.Repos/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReposServer).Info(ctx, req.(*RepoName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repos_UpdateInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepoMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReposServer).UpdateInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pawd.Repos/UpdateInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReposServer).UpdateInfo(ctx, req.(*RepoMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repos_Packages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepoName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReposServer).Packages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pawd.Repos/Packages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReposServer).Packages(ctx, req.(*RepoName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repos_AddPackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepoAddPackage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReposServer).AddPackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pawd.Repos/AddPackage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReposServer).AddPackage(ctx, req.(*RepoAddPackage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repos_UpdatePackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepoUpdatePackage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReposServer).UpdatePackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pawd.Repos/UpdatePackage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReposServer).UpdatePackage(ctx, req.(*RepoUpdatePackage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repos_Builds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackageName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReposServer).Builds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pawd.Repos/Builds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReposServer).Builds(ctx, req.(*PackageName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repos_CheckBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackageBuildID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReposServer).CheckBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pawd.Repos/CheckBuild",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReposServer).CheckBuild(ctx, req.(*PackageBuildID))
	}
	return interceptor(ctx, in, info, handler)
}

var _Repos_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pawd.Repos",
	HandlerType: (*ReposServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Repos_Create_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Repos_Delete_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _Repos_Info_Handler,
		},
		{
			MethodName: "UpdateInfo",
			Handler:    _Repos_UpdateInfo_Handler,
		},
		{
			MethodName: "Packages",
			Handler:    _Repos_Packages_Handler,
		},
		{
			MethodName: "AddPackage",
			Handler:    _Repos_AddPackage_Handler,
		},
		{
			MethodName: "UpdatePackage",
			Handler:    _Repos_UpdatePackage_Handler,
		},
		{
			MethodName: "Builds",
			Handler:    _Repos_Builds_Handler,
		},
		{
			MethodName: "CheckBuild",
			Handler:    _Repos_CheckBuild_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pawd.proto",
}

func init() { proto.RegisterFile("pawd.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1214 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xcc, 0x56, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0xd6, 0x0f, 0x25, 0x8b, 0x23, 0x59, 0x66, 0xd6, 0x49, 0xca, 0x38, 0x68, 0xe3, 0x30, 0x71,
	0xe0, 0xa4, 0xa8, 0xd1, 0xca, 0xfd, 0xc9, 0xa9, 0x40, 0x6a, 0x15, 0x8e, 0xd1, 0x34, 0x09, 0x58,
	0xfb, 0xd0, 0x43, 0x41, 0x6c, 0xc4, 0x31, 0xbd, 0x15, 0xc5, 0x5d, 0x70, 0x57, 0x89, 0xd3, 0x87,
	0x48, 0x0f, 0x3d, 0xf7, 0x85, 0x7a, 0xe8, 0xa5, 0x2f, 0x54, 0xec, 0x2e, 0x29, 0x52, 0xb2, 0x5d,
	0xa4, 0x3d, 0xf5, 0xc6, 0xf9, 0xbe, 0xd9, 0x99, 0x6f, 0x86, 0x9c, 0xe1, 0x02, 0x08, 0xfa, 0x26,
	0xde, 0x13, 0x39, 0x57, 0x9c, 0x38, 0xfa, 0x39, 0xe8, 0x40, 0xfb, 0x39, 0x4b, 0x83, 0x9f, 0x60,
	0x10, 0x62, 0xc2, 0xa4, 0xc2, 0xfc, 0x28, 0x3b, 0xe5, 0xe4, 0x3a, 0x74, 0x70, 0x46, 0x59, 0xea,
	0x37, 0xb7, 0x9b, 0xbb, 0x6e, 0x68, 0x0d, 0xb2, 0x05, 0x3d, 0x41, 0xa5, 0x7c, 0xc3, 0xf3, 0xd8,
	0x6f, 0x19, 0x62, 0x61, 0x93, 0xdb, 0xe0, 0xbe, 0xa1, 0x99, 0x8a, 0x14, 0x57, 0xc2, 0x6f, 0x6f,
	0x37, 0x77, 0x7b, 0x61, 0x4f, 0x03, 0xc7, 0x5c, 0x89, 0x40, 0x80, 0x57, 0x86, 0x0f, 0x51, 0x0a,
	0x9e, 0x49, 0x24, 0x3b, 0xd0, 0x51, 0x7c, 0x8a, 0x99, 0x49, 0xd1, 0x1f, 0x6d, 0xec, 0x19, 0x6d,
	0x27, 0x12, 0xf3, 0x63, 0x0d, 0x87, 0x96, 0xad, 0x94, 0xb4, 0xea, 0x4a, 0xee, 0x40, 0x5f, 0x27,
	0x8a, 0x24, 0x4e, 0x72, 0x54, 0x26, 0x9f, 0x1b, 0x82, 0x86, 0x7e, 0x30, 0x48, 0x10, 0x83, 0xfb,
	0x8c, 0x27, 0x2c, 0xfb, 0x8f, 0xd5, 0xec, 0xc0, 0xd0, 0xc4, 0x9f, 0x9c, 0xd1, 0x34, 0xc5, 0x2c,
	0xc1, 0x22, 0xc5, 0xba, 0x46, 0x0f, 0x4a, 0x30, 0x88, 0xc0, 0x5d, 0x08, 0xd6, 0x59, 0xaa, 0x82,
	0xdc, 0x9a, 0xfe, 0xd3, 0x94, 0x26, 0xd2, 0x6f, 0x6d, 0xb7, 0x35, 0x6a, 0x0c, 0xf2, 0x00, 0x36,
	0xf0, 0x5c, 0xb0, 0xfc, 0x6d, 0x34, 0xcf, 0xd8, 0x79, 0x94, 0xcc, 0x6c, 0x0d, 0xed, 0x70, 0xdd,
	0xc2, 0x27, 0x19, 0x3b, 0x3f, 0x9c, 0xa9, 0xe0, 0xd7, 0x26, 0x40, 0x88, 0x82, 0x1f, 0xe4, 0x48,
	0x15, 0x12, 0x02, 0x4e, 0x46, 0x67, 0x58, 0x64, 0x30, 0xcf, 0x64, 0x1b, 0xfa, 0x31, 0xca, 0x49,
	0xce, 0x84, 0x62, 0x3c, 0x2b, 0x2a, 0xa9, 0x43, 0xe4, 0x01, 0xac, 0xc5, 0x4c, 0xaa, 0x9c, 0x4b,
	0xbf, 0xbd, 0xdd, 0xde, 0x1d, 0x8e, 0x06, 0xb6, 0xd7, 0x63, 0x03, 0x86, 0x25, 0x49, 0xee, 0xc1,
	0xba, 0xc0, 0x5c, 0xf2, 0x8c, 0xa6, 0xd1, 0x19, 0x9d, 0x4c, 0x7d, 0xc7, 0xbc, 0xc6, 0x41, 0x09,
	0x3e, 0xa5, 0x93, 0x69, 0xf0, 0x67, 0x13, 0x1c, 0xad, 0x88, 0x0c, 0xa1, 0xc5, 0xe2, 0x42, 0x49,
	0x8b, 0xc5, 0x0b, 0x6d, 0xad, 0xab, 0xb5, 0xb5, 0xff, 0x51, 0x9b, 0xf3, 0xaf, 0xb4, 0x75, 0x2e,
	0x6a, 0x23, 0xfb, 0x70, 0x73, 0xa2, 0x1b, 0xc5, 0x78, 0x16, 0xc5, 0x54, 0x61, 0xd5, 0xdc, 0xae,
	0x69, 0xee, 0x66, 0xc9, 0x8e, 0xa9, 0xc2, 0xb2, 0xc5, 0xbf, 0x35, 0x61, 0xed, 0x25, 0x9d, 0x4c,
	0x69, 0x82, 0xef, 0x55, 0x93, 0x0f, 0x6b, 0xaf, 0x31, 0x97, 0x55, 0x3d, 0xa5, 0x49, 0x6e, 0x42,
	0x57, 0x4c, 0x93, 0x1c, 0x53, 0xd3, 0x38, 0x37, 0x2c, 0x2c, 0x7d, 0x42, 0x4c, 0x13, 0x5d, 0xb5,
	0x51, 0xed, 0x86, 0xa5, 0xa9, 0x99, 0x94, 0x4d, 0x30, 0x93, 0x68, 0x14, 0xba, 0x61, 0x69, 0x06,
	0x21, 0xf4, 0x0b, 0x51, 0xcf, 0x75, 0xd2, 0xcb, 0x5e, 0x3c, 0x01, 0x67, 0x2e, 0x31, 0x2f, 0xc5,
	0xe9, 0x67, 0x3d, 0x85, 0x39, 0x0a, 0x1e, 0x19, 0x67, 0x2b, 0xaf, 0xa7, 0x01, 0x1d, 0x24, 0x18,
	0x41, 0x2f, 0x2c, 0x9e, 0xdf, 0x37, 0x60, 0xf0, 0x7b, 0xd3, 0x1e, 0xfa, 0x1e, 0x15, 0xfd, 0x1f,
	0xbe, 0xf2, 0xe0, 0x47, 0xbd, 0xb8, 0x04, 0x2f, 0x7a, 0x25, 0xc9, 0x47, 0xe0, 0xe8, 0x7a, 0x8b,
	0xa5, 0x02, 0x36, 0xb2, 0xf6, 0x08, 0x0d, 0x4e, 0x1e, 0xea, 0xa1, 0xb7, 0xbe, 0x66, 0x22, 0xfb,
	0xa3, 0x75, 0xeb, 0x53, 0x44, 0x08, 0x17, 0x74, 0xf0, 0x57, 0x0b, 0x36, 0x0a, 0xf4, 0x18, 0x67,
	0x22, 0xd5, 0x03, 0x78, 0x17, 0x9c, 0x19, 0x2a, 0x5a, 0x84, 0x5f, 0x39, 0x6a, 0x28, 0xb2, 0x07,
	0xce, 0x94, 0x65, 0x76, 0xa5, 0x0c, 0x47, 0x5b, 0x4b, 0x2e, 0x65, 0x9c, 0xbd, 0xef, 0x58, 0x16,
	0x87, 0xc6, 0x8f, 0x7c, 0x08, 0x20, 0xf9, 0x3c, 0x9f, 0x60, 0x34, 0xcf, 0xd3, 0xa2, 0x5f, 0xae,
	0x45, 0x4e, 0xf2, 0x94, 0xdc, 0x82, 0x5e, 0xc2, 0x54, 0x64, 0x8a, 0xb2, 0x9f, 0xd5, 0x5a, 0xc2,
	0x94, 0x99, 0x40, 0x1f, 0xd6, 0x62, 0x14, 0x98, 0xc5, 0xd2, 0xef, 0x98, 0xe5, 0x52, 0x9a, 0x7a,
	0x3d, 0xc6, 0xf8, 0x3a, 0x2a, 0xd9, 0xae, 0x61, 0x21, 0xc6, 0xd7, 0xe3, 0xc2, 0xe1, 0x36, 0xb8,
	0x09, 0x8f, 0xd8, 0x4c, 0xf0, 0x5c, 0xf9, 0xb1, 0xfd, 0x4e, 0x12, 0x7e, 0x64, 0x6c, 0x72, 0x03,
	0xba, 0x09, 0x8f, 0xc4, 0x34, 0xf1, 0xd1, 0x6e, 0xb2, 0x84, 0xbf, 0x9c, 0x26, 0x5a, 0xa8, 0x3e,
	0x93, 0x49, 0x45, 0xd3, 0xd4, 0x3f, 0x35, 0x31, 0xdd, 0x84, 0x1f, 0x59, 0x20, 0xd8, 0x01, 0x47,
	0x57, 0x45, 0x5c, 0xe8, 0x1c, 0xf2, 0x63, 0x9a, 0x78, 0x0d, 0x42, 0x60, 0x78, 0xc8, 0x9f, 0x51,
	0x85, 0x52, 0x1d, 0xf0, 0xd9, 0x8c, 0x29, 0xaf, 0x19, 0x8c, 0x61, 0xa8, 0xc5, 0x3f, 0x89, 0xe3,
	0x72, 0xe8, 0x46, 0x70, 0xe3, 0xd5, 0x9c, 0xa5, 0x71, 0xa4, 0x68, 0xfe, 0x8a, 0xa6, 0x69, 0x94,
	0xfc, 0xc2, 0x84, 0x40, 0xdb, 0xc1, 0x41, 0xb8, 0x69, 0xc8, 0x63, 0xcb, 0x1d, 0x5a, 0x2a, 0xf8,
	0x19, 0xae, 0xe9, 0x28, 0x27, 0x42, 0x8f, 0x79, 0x19, 0xe8, 0x3d, 0x5e, 0xce, 0x95, 0xb9, 0xda,
	0x57, 0xe7, 0xda, 0x86, 0x61, 0x11, 0xe4, 0x1b, 0xcd, 0x1e, 0x8d, 0x57, 0xe7, 0x20, 0x78, 0xd7,
	0x82, 0x41, 0xdd, 0xe5, 0xc2, 0xa0, 0xdc, 0x81, 0xb6, 0x6e, 0x67, 0xeb, 0x32, 0x61, 0x9a, 0x59,
	0x8c, 0x5e, 0xbb, 0x36, 0xcb, 0x9f, 0xc0, 0xa6, 0x54, 0x34, 0x57, 0x2b, 0xab, 0xcc, 0x31, 0xab,
	0xcc, 0x33, 0x54, 0x6d, 0x8f, 0x91, 0x87, 0x70, 0x0d, 0xb3, 0x78, 0xc5, 0xb9, 0x63, 0x9c, 0x87,
	0x98, 0xc5, 0x75, 0x57, 0xbd, 0xa8, 0xa8, 0x94, 0x18, 0x9b, 0xad, 0xd3, 0x0b, 0x0b, 0x8b, 0xdc,
	0x85, 0x81, 0xed, 0x0e, 0x9f, 0x2b, 0x31, 0x57, 0xfe, 0x9a, 0x69, 0x4a, 0xdf, 0x60, 0x2f, 0x0c,
	0x44, 0xee, 0x43, 0xd7, 0xce, 0xa7, 0xdf, 0x33, 0xdf, 0xf7, 0xf2, 0xec, 0x16, 0x5c, 0x70, 0x0a,
	0x9b, 0xf5, 0x7e, 0x3c, 0x65, 0x52, 0xf1, 0xfc, 0x2d, 0xb9, 0x07, 0x43, 0x2a, 0x23, 0x7e, 0x5a,
	0xe9, 0x6b, 0x1a, 0x7d, 0x7d, 0x2a, 0x5f, 0x9c, 0x96, 0xe2, 0x1e, 0x41, 0xd7, 0x24, 0x2c, 0xe7,
	0x93, 0x2c, 0xb5, 0xcb, 0xc4, 0x0b, 0x0b, 0x8f, 0x47, 0xe7, 0xd0, 0xb5, 0x99, 0x49, 0x0f, 0x9c,
	0xe7, 0x3c, 0x43, 0xaf, 0x41, 0x86, 0x00, 0x4f, 0x52, 0xc1, 0x32, 0xfc, 0x36, 0x4e, 0xd0, 0x03,
	0x32, 0x80, 0x9e, 0xb5, 0xf7, 0xf7, 0xbd, 0x7e, 0xcd, 0xfa, 0xdc, 0x1b, 0xd4, 0xac, 0x2f, 0xbc,
	0xf5, 0x9a, 0xf5, 0xa5, 0x37, 0xac, 0x59, 0x5f, 0x79, 0x1b, 0x26, 0x6a, 0x8c, 0x29, 0xb3, 0x51,
	0xb3, 0xd1, 0xbb, 0x26, 0x38, 0x4f, 0xe6, 0xea, 0x8c, 0x7c, 0xa6, 0xf7, 0xa3, 0xbd, 0xda, 0x10,
	0x52, 0xae, 0x9b, 0xea, 0x26, 0xb5, 0xb5, 0x7a, 0xaf, 0x09, 0x1a, 0xe4, 0x63, 0xe8, 0x98, 0xbb,
	0x09, 0x29, 0xb8, 0xc5, 0x45, 0xe5, 0x32, 0xe7, 0x07, 0xd0, 0x7d, 0xc6, 0x13, 0x3e, 0x57, 0x64,
	0x95, 0xdc, 0x72, 0x2d, 0xa0, 0xef, 0x6f, 0x8d, 0xd1, 0x1f, 0x6d, 0xe8, 0xe8, 0x91, 0x90, 0x64,
	0x17, 0xba, 0xc5, 0x75, 0xc1, 0xab, 0xd6, 0x9f, 0x45, 0xb6, 0x6a, 0x0b, 0x31, 0x68, 0x90, 0x1d,
	0xe8, 0x8e, 0x31, 0x45, 0x85, 0x64, 0x58, 0xe1, 0xfa, 0xf7, 0xb0, 0x14, 0x9a, 0xdc, 0x07, 0xc7,
	0x5c, 0xa3, 0x56, 0x9d, 0x96, 0x83, 0x3d, 0x02, 0xb0, 0xe3, 0xb8, 0xea, 0xab, 0x7f, 0x1d, 0x2b,
	0xbe, 0x9f, 0x42, 0x6f, 0xb1, 0xb1, 0x57, 0xa3, 0x92, 0xca, 0x2e, 0x7d, 0x82, 0x06, 0x79, 0xac,
	0xfb, 0xbf, 0x58, 0x19, 0xd7, 0x2b, 0x9f, 0x0a, 0xdd, 0xba, 0xe4, 0x4b, 0x09, 0x1a, 0xe4, 0x6b,
	0x58, 0x5f, 0x5e, 0x13, 0x1f, 0x54, 0x87, 0x97, 0x88, 0x2b, 0xce, 0x3f, 0x86, 0xae, 0x79, 0x94,
	0xe4, 0xda, 0x12, 0x6f, 0xc4, 0xde, 0xba, 0x78, 0xa4, 0xf8, 0xd8, 0xad, 0xe6, 0x83, 0x33, 0x9c,
	0x4c, 0xed, 0x4e, 0xb8, 0x7e, 0xd1, 0xf5, 0x68, 0x7c, 0x79, 0xce, 0x57, 0x5d, 0x73, 0x45, 0xdf,
	0xff, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xa9, 0x46, 0xfc, 0x2c, 0xb0, 0x0b, 0x00, 0x00,
}
